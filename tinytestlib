#!/usr/bin/env bash

# Tinytestlib:
# Because all the other solutions I found to do basic bash shell script testing were too large.
# I eventually want to make it handle being run from either zsh or bash (and possibly
# other shells), but for now, it's just bash.

save_shellenv() {
  _prev_shell_opts=$(set +o; shopt -p;)
}

restore_shellenv() {
  eval "$_prev_shell_opts"
  # clean up after ourselves, don't want to pollute the ENV
  unset _prev_shell_opts
}

# ANSI color helpers
red_text() {
  echo -en "\e[31m${1}\e[0m"
}

green_text() {
  echo -en "\e[32m${1}\e[0m"
}

yellow_text() {
  echo -en "\e[93m${1}\e[0m"
}

# echo has nonstandard behavior, so...
posixy_echo_no_newline() {
  printf "%b" "$*"
}
posixy_echo() {
  posixy_echo_no_newline "$*"
  printf "\n"
}

hex_encode() {
  posixy_echo_no_newline "$*" | hexdump -ve '/1 "%02x"'
}

hex_decode() {
  # note that using -rp instead of -r -p as args to xxd will FAIL! what's an option parser? ;)
  posixy_echo_no_newline "$*" | xxd -r -p
}

# Captures stdout, stderr and return code of any command into the named variable (a 'declare -A var' variable name) passed as an argument.
capture() {
  local _out _err _ret
  if [ "$1" = "--debug" ]; then
    local debugflag=1
    shift
  fi
  # So this is a "name reference" (bash 4.5+). Any references to this name here will actually refer to the passed-in name on $1.
  # Which should be declared in that scope as `declare -A` (associative array/dictionary).
  local aa_alias=$1
  declare -n outs_dict=$1
  shift
  # check to make sure we were given an associative array
  if is_associative_array $aa_alias; then
    : # we're fine (colon is a "no-op" in Bash. TYL.)
  else
    raise "Error: $aa_alias is not an associative array (that is, declared via 'declare -A $aa_alias')"
  fi

  if [ "$#" -lt 1 ]; then
      echo "Usage: capture [--debug] <outputs-dict-varname> command [arg ...]"
      echo "The <outputs-dict-varname> is any variable defined as \`declare -A\`"
      echo "The stdout, stderr and retval can be accessed via (assuming it's named \"outs\"):"
      echo '${outs[stdout]}, ${outs[stderr]} and ${outs[retval]}.'
      return 1
  fi

  # just a modification of some nutso magic I found online that captures stdout into $_out, stderr into $_err and return/status code into $_ret
  # (along with any special ttl-namespaced vars which might have changed)
  # WITHOUT opening files, because touching the filesystem unnecessarily is sad (slows down tests, etc)
  # and WITH only running the command once.
  # Modified from an answer here and only works in bash 4+: https://stackoverflow.com/questions/13806626/capture-both-stdout-and-stderr-in-bash
  . <({ _err=$({ _out=$("$@"); _ret="$?"; } 2>&1; declare -p _out _ret >&2); declare -p _err; } 2>&1)

  if [[ -v debugflag ]]; then
    yellow_text "\ncmd: $*" >&2
    yellow_text "\nout: $_out" >&2
    yellow_text "\nerr: $_err" >&2
    yellow_text "\nret: $_ret\n" >&2
  fi
  outs_dict[stdout]="$(printf "%b" "$_out")"
  outs_dict[stderr]="$(printf "%b" "$_err")"
  outs_dict[retval]="$(printf "%b" "$_ret")"
  unset -n outs_dict # unsets the *name reference*, NOT the variable referenced by the name
  return $_ret
}

# exit with red text to stderr
raise() {
  red_text "$1" >&2
  exit ${2:-1}
}

# an encoding-agnostic way to do binary comparisons
_compare() {
  local comp_op arg1 arg2 arg1_enc arg2_enc
  comp_op="$1"
  arg1="$2"
  arg2="$3"
  # to tapdance around escaping, ANSI etc. issues, I just encode to hex and compare those.
  # This may or may not be necessary anymore, but it fixed issues in the past
  # Wish it didn't have to fire up a subshell though; future tweak?
  arg1_enc=$(hex_encode "$arg1")
  arg2_enc=$(hex_encode "$arg2")
  local comparison_encoded comparison
  case $comp_op in
    = | == )
      comparison_encoded="[ \"$arg1_enc\" $comp_op \"$arg2_enc\" ]"
      comparison="[ \"$arg1\" $comp_op \"$arg2\" ]"
    ;;
    != | !== )
      comparison_encoded="[ \"$arg1_enc\" \!= \"$arg2_enc\" ]"
      comparison="[ \"$arg1\" \!= \"$arg2\" ]"
    ;;
    =~ ) # can't do encoded regex comparisons, so just do a plaintext comparison
      comparison_encoded="[[ \"$arg1\" =~ $arg2 ]]"
      comparison="[[ \"$arg1\" =~ $arg2 ]]"
    ;;
    !=~ | !~ )
      comparison_encoded="[[ ! \"$arg1\" =~ $arg2 ]]"
      comparison="[[ ! \"$arg1\" =~ $arg2 ]]"
    ;;
    * ) 
      echo "Unknown comparison operator: $comp_op" >&2
      return 1
    ;;
  esac
  # I don't really like eval'ing here, but it's the only way I could get it to work
  # Since the arguments are already hex encoded, this should be safe
  # echo "$comparison_encoded" >&2
  [ "$TTL_COLLECTING_TESTDATA" = "true" ] && ((ttl_test_count++))
  if eval "$comparison_encoded"; then
    if [ "$TTL_COLLECTING_TESTDATA" = "true" ]; then
      ttl_abbreviated_output="$ttl_abbreviated_output$(green_text ".")"
      return 0
    fi
  else
    if [ "$TTL_COLLECTING_TESTDATA" = "true" ]; then
      ((ttl_fails++))
      ttl_abbreviated_output="$ttl_abbreviated_output$(red_text "F")"
      ttl_errors="$ttl_errors\n$(red_text "Expected: $comparison" && echo)"
      return 1
    else
      raise "Error. Expected: $comparison"
    fi
  fi
}

begin_test_suite() {
  export TTL_COLLECTING_TESTDATA=true
  export ttl_test_count=0
  export ttl_fails=0
  export ttl_abbreviated_output=""
  export ttl_errors=""
}

_ttl_unset_vars() {
  unset ttl_test_count
  unset ttl_fails
  unset ttl_abbreviated_output
  unset ttl_errors
}

end_test_suite() {
  unset TTL_COLLECTING_TESTDATA
  echo
  if [ $ttl_test_count = 0 ]; then
    yellow_text "No assertions!"
		echo
    _ttl_unset_vars
    return 1
  fi
  echo -e $ttl_abbreviated_output
  echo "$ttl_test_count assertions"
  if [ $ttl_fails = 0 ]; then
    green_text "Success"
    echo
    _ttl_unset_vars
    return 0
  else
    red_text "Failures: $ttl_fails"
    echo -e "$ttl_errors"
    echo
    _ttl_unset_vars && return $ttl_fails
  fi
}

assert() {
  _compare "$2" "$1" "$3"
  return $?
}

assert_equal() {
  _compare "==" "$1" "$2"
  return $?
}

assert_not_equal() {
  _compare "!=" "$1" "$2"
  return $?
}

assert_match() {
  _compare "=~" "$1" "$2"
  return $?
}

assert_no_match() {
  _compare "!~" "$1" "$2"
  return $?
}

is_array() {
  local declaredtype=$(declare -p "$1" 2>/dev/null | awk '{print $2}')
  case "$declaredtype" in
  -a)
    return 0
    ;;
  *)
    return 1
    ;;
  esac
}

is_associative_array() {
  local declaredtype=$(declare -p "$1" 2>/dev/null | awk '{print $2}')
  case "$declaredtype" in
  -A)
    return 0
    ;;
  *)
    return 1
    ;;
  esac
}

# currently only works with 1 type applied at a time
assert_type() {
  local vartype=$1
  local varname=$2
  local declaredtype=$(declare -p "$varname" | awk '{print $2}')
  case "$declaredtype" in
  -A)
    assert_equal "associative_array" "$vartype"
    ;;
  --)
    assert_equal "string" "$vartype"
    ;;
  -a)
    assert_equal "array" "$vartype"
    ;;
  -i)
    assert_equal "integer" "$vartype"
    ;;
  -r)
    assert_equal "readonly" "$vartype"
    ;;
  -x)
    assert_equal "exported" "$vartype"
    ;;
  *)
    raise "Type assertion expected $1 for $2 but declare gave $declaredtype which is currently undefined"
    ;;
  esac
}

strip_ansi() {
  local ansiregex="s/[\x1b\x9b]\[([0-9]{1,4}(;[0-9]{0,4})*)?[0-9A-ORZcf-nqry=><]//g"
  # Take stdin if it's there; otherwise expect arguments.
  # The following exits code 0 if stdin not empty; 1 if empty; does not consume any bytes.
  # This may only be a Bash-ism, FYI. Not sure if it's shell-portable.
  if read -t 0; then # consume stdin
    sed -E "$ansiregex"
  else
    posixy_echo_no_newline "$1" | sed -E "$ansiregex"
  fi
}

assert_success() {
  [ "$TTL_COLLECTING_TESTDATA" = "true" ] && ((ttl_test_count++))
  declare -A outs
  capture outs "$@"
  if [ "${outs[retval]}" = "0" ]; then
    if [ "$TTL_COLLECTING_TESTDATA" = "true" ]; then
      ttl_abbreviated_output="$ttl_abbreviated_output$(green_text ".")"
      return 0
    fi
  else
    if [ "$TTL_COLLECTING_TESTDATA" = "true" ]; then
      ((ttl_fails++))
      ttl_abbreviated_output="$ttl_abbreviated_output$(red_text "F")"
      ttl_errors="$ttl_errors\n$(yellow_text "assert_success failure: <$*>\nstdout: ${outs[stdout]}\nstderr: ${outs[stderr]}\nretval: ${outs[retval]}" && echo)"
      return 1
    else
      raise "$(strip_ansi "assert_success failure: <$*>\nstdout: ${outs[stdout]}\nstderr: ${outs[stderr]}\nretval: ${outs[retval]}")"
    fi
  fi
}

assert_failure() {
  [ "$TTL_COLLECTING_TESTDATA" = "true" ] && ((ttl_test_count++))
  declare -A outs
  capture outs "$@"
  if [ "${outs[retval]}" != "0" ]; then
    if [ "$TTL_COLLECTING_TESTDATA" = "true" ]; then
      ttl_abbreviated_output="$ttl_abbreviated_output$(green_text ".")"
      return 0
    fi
  else
    if [ "$TTL_COLLECTING_TESTDATA" = "true" ]; then
      ((ttl_fails++))
      ttl_abbreviated_output="$ttl_abbreviated_output$(red_text "F")"
      ttl_errors="$ttl_errors\n$(yellow_text "assert_failure was actually successful: <$*>\nstdout: ${outs[stdout]}\nstderr: ${outs[stderr]}\nretval: ${outs[retval]}" && echo)"
      return 1
    else
      raise "$(strip_ansi "assert_failure was actually successful: <$*>\nstdout: ${outs[stdout]}\nstderr: ${outs[stderr]}\nretval: ${outs[retval]}")"
    fi
  fi
}
