#!/usr/bin/env bash

# Tinytestlib:
# Because all the other solutions I found to do basic bash shell script testing were too large.
# I eventually want to make it handle being run from either zsh or bash (and possibly
# other shells), but for now, it's just bash.

# shell="sh"
# if [ -n "${ZSH_VERSION:-}" ]; then
#    shell="zsh"
# elif [ -n "${BASH_VERSION:-}" ]; then
#    shell="bash"
# else
#    echo "Unknown shell encountered" >&2
#    exit 1
# fi

save_shellenv() {
  _prev_shell_opts=$(set +o; shopt -p;)
}

restore_shellenv() {
  eval "$_prev_shell_opts"
  # clean up after ourselves, don't want to pollute the ENV
  unset _prev_shell_opts
}

# ANSI color helpers
red_text() {
  echo -en "\e[31m${1}\e[0m"
}

green_text() {
  echo -en "\e[32m${1}\e[0m"
}

yellow_text() {
  echo -en "\e[93m${1}\e[0m"
}

# echo has nonstandard behavior, so...
posixy_echo_no_newline() {
  printf "%b" "$*"
}
posixy_echo() {
  posixy_echo_no_newline "$*"
  printf "\n"
}

hex_encode() {
  posixy_echo_no_newline "$*" | hexdump -ve '/1 "%02x"'
}

hex_decode() {
  # note that using -rp instead of -r -p as args to xxd will FAIL! what's an option parser? ;)
  posixy_echo_no_newline "$*" | xxd -r -p
}

# a zsh way to capture all of stdout, stderr and return
# printf 'status: %s\nstdout: %s\nstderr: %s\n' $? "${(q+)reply[@]}"
# Still being tested, so commented-out for now
# zsh-capture() {
#   'builtin' 'local' '__zrc'
#   __zrc="$(
#     __zrc="$( ("$@") || __zrc="$?"; 'builtin' 'printf' '%3d' "$__zrc")" 2>&1 ||
#       'builtin' 'printf' '-v' '__zrc' '%3d' "$?"
#     'builtin' 'unsetopt' 'multibyte'
#     'builtin' 'printf' '%s%18d' "$__zrc" "${#__zrc}"
#   )" || 'builtin' 'printf' '-v' '__zrc' '%3d%18d' "$?" '3'
#   'builtin' 'emulate' '-L' 'zsh' '-o' 'no_multibyte'
#   'builtin' 'local' '-i' n='__zrc[-18,-1]'
#   'builtin' 'typeset' '-ga' 'reply'
#   'builtin' 'set' '-A' 'reply' "$__zrc[-n-18,-22]" "$__zrc[1,-n-19]"
#   'builtin' 'return' '__zrc[-21,-19]'
# }

# Captures stdout, stderr and return code of any command into the named variables passed as arguments.
capture() {
  local _out_var _out _err_var _err _ret_var _ret cmd debugflag
  local debugflag=
  if [ "$1" = "--debug" ]; then
    debugflag=1
    shift
  fi
  if [ "$#" -lt 4 ]; then
      echo "Usage: capture [--debug] <stdout-varname> <stderr-varname> <returncode-varname> command [arg ...]"
      return 1
  fi
  _out_var="$1"; shift
  _err_var="$1"; shift
  _ret_var="$1"; shift

  # get any namespaced tinytestlib vars holding suite state so we can get any changes back out
  local ttlvars=$(env | rg "^_?(ttl|TTL)_" | awk -F= '{print $1}')
  [ $debugflag ] && echo -e $ttlvars

  # just a modification of some nutso magic I found online that captures stdout into $_out, stderr into $_err and return/status code into $_ret
  # WITHOUT opening files, because touching the filesystem unnecessarily is sad (slows down tests, etc)
  # and WITH only running the command once.
  # Modified from an answer here and only works in bash 4+: https://stackoverflow.com/questions/13806626/capture-both-stdout-and-stderr-in-bash
  # . <({ _err=$({ _out=$("$@"); _ret="$?"; } 2>&1; declare -p _out _ret >&2); declare -p _err; } 2>&1)
  cmd="$({ _err=$({ _out=$("$@"; declare -p $ttlvars >&3); _ret="$?"; } 2>&1; declare -p _out _ret >&2 3>&2); declare -p _err; } 2>&1 3>&1)"
  [ $debugflag ] && echo -e "command run:\n$cmd"
  eval "$cmd"

  if [ $debugflag ]; then
    yellow_text "\ncmd: $*" >&2
    yellow_text "\nout: $_out" >&2
    yellow_text "\nerr: $_err" >&2
    yellow_text "\nret: $_ret\n" >&2
  fi
  read -r "${_out_var?}" <<<"$(printf "%b" "$_out")"
  read -r "${_err_var?}" <<<"$(printf "%b" "$_err")"
  read -r "${_ret_var?}" <<<"$(printf "%b" "$_ret")"
  # echo "ret inside capture for '$*': $_ret"
  return $_ret
}

raise() {
  red_text "$1" >&2
  exit ${2:-1}
}

# an encoding-agnostic way to do binary comparisons
_compare() {
  local comp_op arg1 arg2 arg1_enc arg2_enc
  comp_op="$1"
  arg1="$2"
  arg2="$3"
  # to tapdance around escaping, ANSI etc. issues, I just encode to hex and compare those.
  # This may or may not be necessary anymore, but it fixed issues in the past
  # Wish it didn't have to fire up a subshell though; future tweak?
  arg1_enc=$(hex_encode "$arg1")
  arg2_enc=$(hex_encode "$arg2")
  local comparison_encoded comparison
# echo "[[ \"$arg1\" $comp_op \"$arg2\" ]]" >&2
  case $comp_op in
    = | == )
      comparison_encoded="[ \"$arg1_enc\" $comp_op \"$arg2_enc\" ]"
      comparison="[ \"$arg1\" $comp_op \"$arg2\" ]"
    ;;
    != | !== )
      comparison_encoded="[ \"$arg1_enc\" \!= \"$arg2_enc\" ]"
      comparison="[ \"$arg1\" \!= \"$arg2\" ]"
    ;;
    =~ ) # can't do encoded regex comparisons, so just do a plaintext comparison
      comparison_encoded="[[ \"$arg1\" =~ $arg2 ]]"
      comparison="[[ \"$arg1\" =~ $arg2 ]]"
    ;;
    !=~ | !~ )
      comparison_encoded="[[ ! \"$arg1\" =~ $arg2 ]]"
      comparison="[[ ! \"$arg1\" =~ $arg2 ]]"
    ;;
    * ) 
      echo "Unknown comparison operator: $comp_op" >&2
      return 1
    ;;
  esac
  # I don't really like eval'ing here, but it's the only way I could get it to work
  # Since the arguments are already hex encoded, this should be safe
  # echo "$comparison_encoded" >&2
  [ "$TTL_COLLECTING_TESTDATA" = "true" ] && ((ttl_test_count++))
  if eval "$comparison_encoded"; then
    if [ "$TTL_COLLECTING_TESTDATA" = "true" ]; then
      ttl_abbreviated_output="$ttl_abbreviated_output$(green_text ".")"
      return 0
    fi
  else
    if [ "$TTL_COLLECTING_TESTDATA" = "true" ]; then
      ((ttl_fails++))
      ttl_abbreviated_output="$ttl_abbreviated_output$(red_text "F")"
      ttl_errors="$ttl_errors\n$(red_text "Expected: $comparison" && echo)"
      return 1
    else
      raise "Error. Expected: $comparison"
    fi
  fi
}

begin_test_suite() {
  export TTL_COLLECTING_TESTDATA=true
  export ttl_test_count=0
  export ttl_fails=0
  export ttl_abbreviated_output=""
  export ttl_errors=""
}

_ttl_unset_vars() {
  unset ttl_test_count
  unset ttl_fails
  unset ttl_abbreviated_output
  unset ttl_errors
}

end_test_suite() {
  unset TTL_COLLECTING_TESTDATA
  echo
  if [ $ttl_test_count = 0 ]; then
    yellow_text "No assertions!"
		echo
    _ttl_unset_vars
    return -1
  fi
  echo -e $ttl_abbreviated_output
  echo "$ttl_test_count assertions"
  if [ $ttl_fails = 0 ]; then
    green_text "Success"
    echo
    _ttl_unset_vars
    return 0
  else
    red_text "Failures: $ttl_fails"
    echo -e $ttl_errors
    echo
    _ttl_unset_vars && return $ttl_fails
  fi
}

assert() {
  _compare "$2" "$1" "$3"
  return $?
}

assert_equal() {
  _compare "==" "$1" "$2"
  return $?
}

assert_not_equal() {
  _compare "!=" "$1" "$2"
  return $?
}

assert_match() {
  _compare "=~" "$1" "$2"
  return $?
}

assert_no_match() {
  _compare "!~" "$1" "$2"
  return $?
}

assert_success() {
  [ "$TTL_COLLECTING_TESTDATA" = "true" ] && ((ttl_test_count++))
  local stdout stderr ret
  capture stdout stderr ret "$*"
  if [ "$ret" = "0" ]; then
    if [ "$TTL_COLLECTING_TESTDATA" = "true" ]; then
      ttl_abbreviated_output="$ttl_abbreviated_output$(green_text ".")"
      return 0
    fi
  else
    if [ "$TTL_COLLECTING_TESTDATA" = "true" ]; then
      ((ttl_fails++))
      ttl_abbreviated_output="$ttl_abbreviated_output$(red_text "F")"
      ttl_errors="$ttl_errors\n$(yellow_text "assert_success failure: <$*>\n stdout: $stdout\n stderr: $stderr\nretcode: $ret" && echo)"
      return 1
    else
      raise "assert_success failure: <$*>\n stdout: $stdout\n stderr: $stderr\nretcode: $ret"
    fi
  fi
}

assert_failure() {
  [ "$TTL_COLLECTING_TESTDATA" = "true" ] && ((ttl_test_count++))
  local stdout stderr ret
  capture stdout stderr ret "$*"
  if [ "$ret" != "0" ]; then
    if [ "$TTL_COLLECTING_TESTDATA" = "true" ]; then
      ttl_abbreviated_output="$ttl_abbreviated_output$(green_text ".")"
      return 0
    fi
  else
    if [ "$TTL_COLLECTING_TESTDATA" = "true" ]; then
      ((ttl_fails++))
      ttl_abbreviated_output="$ttl_abbreviated_output$(red_text "F")"
      ttl_errors="$ttl_errors\n$(yellow_text "assert_failure was actually successful: <$*>\nstdout: $stdout\nstderr: $stderr\nretcode: $ret" && echo)"
      return 1
    else
      raise "assert_failure was actually successful: <$*>\n stdout: $stdout\n stderr: $stderr\nretcode: $ret"
    fi
  fi
}

# the point of this is to convert nonzero exit codes to blanks (false) and anything else to "0" ("true")
# shellboolean() {
#   if [ "$1" = "0" ]; then
#     echo -n "0"
#     return 0
#   else
#     echo -n ""
#     return $1
#   fi
# }
